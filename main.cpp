//я научился удалять репозитории

//mkdir name_directory создает директорию
//echo 'commit text' > newcpp.cpp  создает файл
//cd C:\git\namedirectory сменить директорию, где сейчас находишься
//git init - инициализирует директорию, делая ее репозиториеим
//git push --set-upstream origin master - пушим в гитхаб
//очистка консоли - clear
//при переименовании репозитория используем следующую команду
//git remote set-url origin https://github.com/NickRaskatovCPP/gitlearn.git - ссылка на гит

//Как добавлять файлы в индексирование гита:
//git add main.cpp - добавление изменений в индекс отдельного файла
//git add -p добавление лишь части изменений в индекс
//добавлять файлы, даже те, которые указаны в .gitignore
//git add --force (-f) принудительно добавление изменений
//Добавлять новую папку (можно только при условии, что в папке лежит какой либо файл)
//git add. (добавляет все изменения в каталог)
//Убрать файл из индекса
//git reset put_k_file.cpp
//Сбросить изменения в файле до добавления в индекс
//git checkout HEAD put_k_file.cpp

//Как переносить файлы из индекса в репозиторий (коммитить)
//git commit - коммитим в открывшемся окне текстового редактора
//git commit -m 'obyasneniye kommita' - коммитим сразу в консоли
//git commit -am 'komment kommita' добавляет сразу коммит через индекс одной командой
//git diff --staged покажет до комита, что изменено в файле
//git show r6546453 (номер коммита) - просмотр изменений в коммите.
//вместо номе5ра коммита можно написать название ветки. Если мы хотим посмотреть предидущий
//коммит, то можно написать так 
//git show HEAD~
//поиск коммита по какой - либо инфе в коммите
//git show :/anythiginfoWhatIrememberfromCommitY

//удаление файлов
//физически удаляем файл из дирректории, далее через git add добавляем факт удаления файла
//после чего комитим изменения
//git rm file.cpp Удаление через git rm -r 'название директории'
//тоже самое с флагом --cached для удаления файла только из индекса (оставляя фатически файл)
//что бы убрать директорию из индекса но оставить ее в рабочем каталоге используем --cached

//Восстановить незакоммиченые удаленные файлы 
//git restore 'papka/file.cpp'
//Восстановление состояния отдельного фала на момент какого - то конкретного коммита
//git checkout nomerkommita put_k_file.cpp
//после чего востановленный файл гит добавит в индекс

//Указание автора коммита
//git commit --authotr = 'vasya'
//git commit --date = '...'

//Как создавать юзера в гит
//git config user.name - юзер
//git config user.email - мыло юзера

//Настройки для разных уровней приватности как я понял:
//--local - локальные, -global - глобальные, --system - на уровне системы

//научился удалять юзеров:
//git config --unset
//git config --remove -section user

//Просмотр настроек репозитория
//git config --list
//Просмотр файлов репозитория через гит:
//ls
//Просмотр состояния файлов в гите:
//git status

//настраивать короткие команды в гите
//git config --global alias.c config
//это заменит приравняет команду git config к git c

//убирать файлы редактора из репозитория
//git reset HEAD .vscode
//создавать правило игнорирования файлов через файл .gitignore

//Ветки - важная инфа
//на каком то этапе проекта решили добавить фичу, скопировали все файлы проекта в новую ветку
//тестируем фичу в ней. Если фича зашла - сливаем с основной веткой разработки, если нет - 
//удаляем ветку с фичей.

//просмотр всех веток
//git branch nazvaniyeVetki
//просмотр веток с коммитами
//git branch -v

//переключение между ветками
//git checkout 
//сразу и создание и переключение на новую ветку
//git checkout -b novayaVetv
//Если мы находимся в главной ветке, сделали незакомиченные изменения, и нам нельзя сохранить их
//в главную ветку - то просто создаем новую ветку до коммита, и коммитим изменения в новой ветке. 

//переключаться между ветками можно лишь отменив изменения:
//git checkout -f nazvaniyeVetki - перезапись версией файлов из указанной ветки)
//второй вариант - изменения можно сохранить во временный файл
//git stash
//для загрузки данных из временного хранилища
//git stash pop (важно применять на той же ветке, где мы его и делали, не запутаться)
//после этого надо добавить файлы в индекс и закомитить их

//Как мерджить ветки (сливать в мэйн/мастер)
//git checkout main - переходим в ветку, куда будем все сливать
//при этом все изменения должны быть замерджены в обеих ветках и сохранены
//git merge new_branch - мерджим ветку
//git push origin master - заливаем изменения
//git branch -d news - удаляем ветку из которой залили инфу (возможно только в том случае, если ветка объединена с текущей)

//посмотреть все изменения в ветках
//git loggit 
//Показать последнее изменение
//git log -1
//Показать последний коммит с описанием изменений
//git log -1 -p

//Проблема 1 - закомитили изменения в мастер - ветке и мастер надо откатить на пару коммитов назад
//а изменения сохранить в новой ветке:
//1)создаем новую ветку на текущем коммите git branch newVetka
//2)Переходим на newVetka
//3)Создаем мастер ветку с указанием требуемого последнего коммита git branch -f master 543g43
//4)Если все надо вернуть назад: git branch -f master newVetka

//Так же разделение после создания новой ветки можно сделать командой: git checkout -B master nomerKommita

//Проблема 2 - когда мы переходим из newVetka в мастер- ветку, и хэд коммит у нас находится до
//последнего коммита в мастер ветке. Гит начинает ругаться, это состояние отделенный HEAD
//Если мы закомитим в этом состоянии изменения - то комиты будут без ветки, и эти коммиты гит чистит
//Через время. Для этих коммитов требуется создать отдельную ветку 
//git branch newnewvetka nomerkommita
//Так же такие коммиты можно скопировать на текущую ветку командой 
//git cherry-pick nomerkommita

//Просмотр файла в gitbash
//cat main.cpp

//Проcмотр логов гита:
//cat .git/logs/ - в этом файле находятся все логи гита
//cat .git/logs/HEAD - покажет все изменения HEAD коммита
//git reflog HEAD- выведет логи более компактно и красиво, будут видны переходы между ветками и номера коммитов
//по рефлогу можно найти точку псоледнего взаимодействия с удаленной веткой, и воссоздать ее (предположим ветка называлась new):
//git branch new HEAD 'HEAD@{nomer iz refloga} или можно указать дату
//git reflog HEAD --date=iso добавит отображение даты действий/ изменений.
//записи в рефлоге хранятся 90 дней, в удаленной ветке в рефлоге - 30 дней
//к рефлогам нельзя передать доступ, даже если передали права доступа на ветки 
//git checkout @{-1} - означает предыдущую ветку с которой мы пришли на мастер, если указать -2
//то нас вернет на предпредидущий чекаут, и так далее по чекаутам

//сокращенный вывод гитлог
//git log --online 
//так же можно отформатировать так: номер коммита - дата | строка описания - ссылки - имя автора
//git log --pretty=format:'%C(yellow)%h %cd | %C(cyan)%s%d %C(white)[%an]' 
//Что бы сохранить вывод в нужном нам формате используем следл. команду:
//git config global pretty.my format:'%C(yellow)%h %cd | %C(cyan)%s%d %C(white)[%an]'
//после этого, что бы выквести логи в новом формате используем:
//git log --pretty=my
//а если хотим, что бы обычный запрос гит лога имел такой формат по умолчанию после этого используем:
//git config --global format.pretty my
//если надо вернуть формат вывода по умолчанию:
//git log --pretty=medium
//что бы посмотреть что менялось в каждом коммите:
//git log -p
//есть графические утилиты git gui. Они показывают как именно выглядят ветки. 
//что бы это посмотреть в консоли пишем команду
//git log --all --graph
//git log vetka1 vetka2 --graph
//git log vetka1...vetka2 --graph

//Поиск коммита по каким - либо эллементам, к примеру по конкретному слову в конкретной ветке:
//git log --grep slovo nazvaniyeVetki
//можно использовать символы сравнения, к примеру ищем по словосочетанию dobavlen poisk или dobavlen search
//git log --grep 'dobavlen(poisk|search)' -P
//!!!!!!! ВАЖНО! Поиск зависим от регистра (маленьких/ больших букв) 

//Как узнать кто вносил изменения в коммит, строку, код
//git blame nazvaniyefaila

//Удаление файлов которые отслеживаются гитом:
//git reset --hard
//удаление файлов которые не отслеживаются гитом:
//git clean -dxf где -d - для удаления файлов и директорий, -x для удаления файлов включая гит игнор, 
//-f принудительное выполнение (обязательно для написания в команде)
//сбросить закомиченые изменения:
//git reset @~ (число после тильды означает на сколько шагод (коммитов) назад надо откатиться)
//--hard - делает откат принудительным вместо @~ можно написать номер коммита, к которому надо откатится

//Новая проблема: 
//мы откатились на 1 коммит назад, сделали новый коммит. А потом поняли, что удаленный коммит нам нужен. Делаем жесткий ресет.
//git reflog nazvaniye_vetki - покажет все переходы между коммитами, и мы увидим номер того коммита, который надо восстановить
//cat .git/ORIG_HEAD - метим удаленный коммит этим идентификатором
//git reset --hard ORIG_HEAD ( или nomer_udalennogo_kommita) - восстанавливаем коммит, заменяя наш новый на наш удаленный коммит
//ORIG_HEAD - просто временная ссылка для удобства, доступ к логам, данным об удаленных файлах
//Теперь мягкий ресет:
//git reset --soft @~ - откатит ветку назад на один коммит, а коммит, с которого мы откатились попадет в индекс и будет доступен для коммитов
//Мягкий ресет так же используется что бы изменить коммит (для изменения коммитов), так как закоммиченые изменения уже нельзя менять, 
//Отредактировать коммит можно только через ресет
//если к коммиту добавить флаг -с, то он возьмет описание и информацию об авторе из коммита с которого мы откатывались назад, но перезапишет содержимое.
//-c - откроется редактор, -С закоммитится без редактирования (git commit -C ORIG_HEAD)
//что бы посмотреть информацию об авторе коммита, о том как менялась дата и тд:
//git show --quiet --pretty=fuller

//Альтернативный способ мягкого ресета с коммитом в одной команде:
//добавляем измененные файлы в индекс командой git add .
//git commit --amend Эта команда откатит нас на один коммит, (только ссылку в репозитории, не файлы), 
//создала новый коммит из индекса, и все описание и инфу об авторе возьмет так же как и мягкий ресет. (а старый коммит, с которого мы откатились
//упадет в лог на 30 дней)

//git commit --amend --reset-author (делает текущего коммитера автором коммита)
//git commit --amend --no-edit (отменяет вызов редактора)

//Так же, используя команду ниже, можно откатить конкретный файл к конкретному коммиту:
//git reset nomerKommita Nazvaniefaila.cpp сброясятся изменения в репозитории и индексе, директорию не затронет до коммита

//в гите можно сравнить разницу между двумя коммитами в двух ветках:
//git diff nomerKommita1 nomerKommita2
//между двумя ветками
//git diff nameVetki1 nameVetki2
//что бы выйти из сравнения надо нажать q (типо квает)
//изменения в новой ветке, с момента ее появления, относительно основной ветки:
//git diff vetka1...vetka2
//Сравнить директорию с конкретным коммитом
//git diff nomerKommita
//сравнение репозитория (HEAD) с директорией (фактическим хранилищем файлов)
//git diff HEAD
//а что бы сравнить директорию с индексом используем ту же команду, но без HEAD
//сравнение идекса с репозиторием
//git diff --cached
//сравнить конкретный файл в рабочей директории и в индексе
//git diff main.cpp
//что бы увидеть какие именно слова поменялись в строке 
//git diff --word-diff

// Слияние веток: 
//Если изменения были только в одной ветке - просте мерджим, и все изменения добавятся
//к исходному фалу без изменений все сольется в одну ветку. Если изменения были в обеих ветках:
//git diff --name-only vetka1 vetka2
//так мы проверили файлы
//git merge vetka2 - мерджим вторую ветку в первую
//git выдаст конфликт слияния (если открыть файл в редакторе vscode то сам конфликт
//будет подсвечен в тексте файла его надо вручную поправить, сделать нужный конечный вид файла)
//git checkout --conflict=diff3 --merge index.html
//команда выше покажет в редакторе различия между исходником,
//сливаемым файлом и файлом в который сливают изменения

//Отмена слияния 
//git reset --hard @`

//посмотреть всю историю разработки в ветке мастер
//git log master --oneline --first-parren в этой команде --oneline дает сокращенный вывод

//Способ игнорирования слияния перемоткой, что бы ветки сохраняли отдельный вид:
//git merge --no-ff --no-edit vetka2
//Сделать этот флаг по умолчанию можно командой
//git config merge.ff false
//Если мы не хотим показывать родителя со второй ветки, но изменения надо перенести (слияние без слияния) используем команду:
//git merge --squash vetka2 и после такого слияния без слияния и закоммичивания vetka2 можно удалить
//git branch -D vetka2

//перемещение коммитов. Предлположим у нас есть ветка 1 с коммитами а-б-с-д-е и из коммита б мы создали 
//ветку 2 с коммитами к-л-м. И нам понадобилось, что бы отправной точкой ветки 2 стал коммит е из ветки 1
//git rebase -x vetka2 тут -x проверяет перенесенные комиты поочередно после переноса в новое место.
//если при копировании коммитов произошел конфликт, решаем его ручками и пишем
//добавляем файлы в индекс и
//git commit --amend --no-edit
//git rebase --continue
//rebase в командной разработке лучше не использовать. У него есть свойство ломать код
//если мы сделали vetka3 от неправильного родителя vetka2 и надо к примеру перенести эту ветку в основную vetka1
//git rease --onto vetka1 vetka2 где первое название ветки - это куда переносим, второе название ветки - какой кусок ( с какого коммита/ ответвления)

//rebase не копирует коммиты слияния и теряет данные родителей коммита слияния. Что бы этого не происходило:
//git rebase --rebase-merges vetka1

//копирование 2х последних коммитов с vetka1 на vetka2Ж
//git cherry-pick vetka1~2..vetka1
//после чего мы переносим головной коммит vetka1 на 2 шага назад
//git branch -f vetka1 vetka1~2

//редактирование названий коммитов в ветке
//git rebase -i @~3 - откат на 3 шага назад и возможность редактирования вышестоящих коммитов

//теги в гит. Тэг указывает на конкретный коммит, его можно использовать как указатель с версией программы, что именно на этом коммите была выпущена версия v 0.1.1
//git tag v0.1.1 n0mercommita
//git tag -n выведет все тэги которые есть
//если нужен тег с аннотацией (сообщением) 
//git tag -a -m 'tagMessage' v.0.1.1 N0merCommita

//Стратегии слияния гит
//рекурсивная - 2 коммита имеют общего родителя.
//два разраба (вася и пупа) сделали ветки от ветки мейн, вася комитит код в ветку пупы, пупа в ветку васи
//получается перекрестие Х и по середине перекрестия образуется как бы временный коммит - родитель 
//для коммита васи и пупы. У recursive стратегии есть опции, которые задают поведение при конфликте
//ours - все конфликты в нашу пользу
//theirs - все конфликты в пользу пупы
//renormmalize - меняет концы строк
//ignore-all-space - игнор пробелов и табуляции
//no-renames - позволяет не отслеживать переименование файлов
//условно был файл main.cpp, в ветке master его переименовали в second.cpp, в ветке feature переименовали в 
//nomain.cpp. При слиянии будет трехсторонний конфликт: в ветке master уже нет main.cpp
//В ветке мастер теперь есть second.cpp, в feature есть новый nomain.cpp
//git воспринимает их как 3 разных файла, но это один и тот же файл, просто разные названия.
//Что бы решить этот конфликт надо:
//добавить в индекс second.cpp git add second.cpp
//rm main.cpp удалить этот файл
//добавить в индекс сразу все пути, что бы разрешить конфликт после чего можно завершить слияние.

//Есть и обратная ситуация, когда рекусивная стратегия не дает конфликта слияния из за переименования
//есть те же ветки и файлы, делаем git merge --no-edit feature
//И все данные сольются в один файл и сам фал переименуется в second.cpp

//как гит определяет, переименован ли файл или это новый файл? - по % изменений
//если содержимое файла отличается не более чем на 50% - то гит воспримет это
//как переименование, есмли более - то как новый файл. 

//Что бы не создавать путанницу можно использовать флаг но ренеймс.
//git merge -Xno-renames featchure
//возникнет конфликт, предположим мы хотим оставить файл из ветки master:
//git add nosecond.cpp
//git merge -Xfind-renames=80 second.cpp - задаем правило, что при 80% совпадений
//в содержимом файла - гит думает что файл одинаковый. Можно указать любой процент,
//По умолчанию показатель 50%

//Стратегия слияния subtree=path
//У нас есть 2 ветки, на одной piki.cpp, другой members.cpp. Эти ветки не имеют общего начала
//git merge -Xsubtree=plugin --allow-unrelated-histories plugin - сольет эти 2 ветки
//Будто у них есть общий коммит-родитель

//git submodule - позже напишу

//стратегия octopus - применяется автоматически, когда требуется слияние более 2х веток в 1 коммит
//делается простым перечислением сливаемых веток 
//git merge master fitchure subfitchure
//этот способ быстрее последовательного слияния, но отменить слияние с конкретной веткой будет сложнее
//Хорошо работает, когда есть большой проект, и каждая ветка отвечает за свой файл, из разных частей проекта, что бы собрать все во едино

//git reset --keep @~ эта команда основана на жестком ресете, но сохраняет некзакоммичченные изменения
//отодвигая крайний коммит на 1 назад

//git reset --merge отменяет конфликтные и ненужные мерджи. 